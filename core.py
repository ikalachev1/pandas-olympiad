from typing import Any
import pandas as pd

def sum2(a: int, b: int) -> int:
    """
    Возвращает сумму аргументов.
    """
    return a + b

def fill_missing(df: pd.DataFrame):
    """
    В датафрейме с продажами некоторые цены пропущены.

    id  product   price
    432 apple     32.1
    433 orange    67.3
    444 apple     -
    445 pineapple 102
    446 apple     34.1  

    Надо заполнить пропуски средними значениями, соответствующими типу товара. То есть пропуски цен у яблок 
    должны заполняться средней ценой яблок, и т.д.

    Так пропуск в приведённом выше датафрейме нужно заполнить числом 33.1.
    """

    return

def span(df: pd.DataFrame):
    """
    Для каждого товара вычислите разницу максимальной и минимальной цены.

    Например, для такого датафрейма

    id  product   price
    432 apple     32.1
    433 orange    67.3
    444 apple     33.1
    445 orange    67.9
    446 apple     34.1  

    должно получиться
    
    product  span
    apple    2.0
    orange   0.6
    """

    return     

def total_weight(df: pd.DataFrame) -> float:
    """
    Нужно посчитать общий вес проданных товаров.
    Веса товаров, которые продаются наразвес, нужно просто сложить,
    а у товаров, которые продаются поштучно, веса нужно взять из
    отдельной таблицы.

    Например,
    id  product   weight   pieces
    432 apple     3.2      -
    433 orange    1.3      -
    444 apple     5.4      -
    447 yoghurt   -        4
    447 bread     -        3

    id  product   weight
    1   yoghurt   0.1  
    2   bread     0.3  

    3.2 + 1.3 + 5.4+ 4*0.1 + 3*0.3 = 11.2

    Исходные датафреймы должны остаться неизменными.
    """

    return

def set_index_value(df: pd.DataFrame, i: int, val: Any) -> pd.DataFrame:
    """
    Изменяет i-е значение индекса датафрейма на заданное значение. Например,
    для такого датафрейма

                     FGE       FFI       FRA    FARCAD    FCOCAD                                                        
    date
    2020-12-31       NaN       NaN       NaN       NaN       NaN
    2021-12-31  0.137961 -0.040112  0.098811  0.062196  0.088000
    2022-12-31 -0.142319 -0.090379  0.068276  0.102470  0.095588
    2022-12-31  0.038630 -0.035256  0.067030  0.044813  0.037752

    set_index_value(df, -1, '2023-12-31') изменит '2022-12-31' на '2023-12-31'.

    Возвращает новый датафрейм (не трогает исходный).
    """

    return

def count_low_high(df: pd.DataFrame) -> pd.DataFrame:
    """
    Дан датафрейм вида

    df = pd.DataFrame({
        'col1': ['a', 'a', 'b', 'b', 'b', 'c', 'c', 'c', 'c', 'a'],
        'col2': [1,2,1,4,5,6,6,6,9,1],
        'col3': ['LOW', 'HIGH', 'LOW','LOW','HIGH', 'LOW', 'HIGH', 'LOW', 'HIGH', 'HIGH'],
    })

    Для каждого значения col1 необходимо посчитать количество уникальных значений в столбце
    col2 если col3 равен LOW, и сохранить это значение в новом столбце 'low_count'. 
    Аналогично для HIGH и high_count.

    Так для датафрейма, приведённого выше, результат будет 

    pd.DataFrame({
        ...
        'low-count': [1, 1, 2, 2, 2, 1, 1, 1, 1, 1],
        'high-count': [2, 2, 1, 1, 1, 2, 2, 2, 2, 2],
    })

    Возвращает новый датафрейм (не трогает исходный).
    """

    return 


def unroll(df: pd.DataFrame) -> pd.DataFrame:
    """
    В столбце C датафрейма df находятся числа, разделённые запятыми. 

      A       B            C       
    32011     X     [147, 140, 133]
    32012     Y     [134, 146]
    32013     Z     [175, 168, 161, 154]

    Необходимо сформировать из этих чисел стоблец D, так чтобы в столбце B осталось исходное значение
    из соответствуеющей строки, а счётчик в стоблце A автоматически увеличивался:

      A       B      D       
    32011     X     147
    32012     X     140
    32013     X     133
    32012     Y     134
    32013     Y     146
    32013     Z     175
    32014     Z     168
    32015     Z     161
    32016     Z     154
    """
    return    